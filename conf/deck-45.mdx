import { Head, Appear, Steps } from 'mdx-deck';
import { Invert, Split } from 'mdx-deck/layouts';
import SyntaxHighlighter from 'react-syntax-highlighter';
import { CodeSurfer } from 'mdx-deck-code-surfer';
import syntaxTheme from "prism-react-renderer/themes/shadesOfPurple";
import { RunCode } from './RunCode';

import l from '../src/vdom/nodeFactory';
import utils from '../src/vdom/utils';
import hookState from '../src/hooks/hookState';
import hookBinding from '../src/hooks/hookBinding';

export { yellow as theme } from 'mdx-deck/themes';

<Head>
  <title>The Virtual DOM, what is it even?</title>
</Head>

# The Virtual DOM, what is it even?

---

## What should you take out of this talk?

* Understand what the virtual DOM is and what are its components are
* Understand how to diff and patch a virtual DOM tree
* Demystify the magic behind hooks and JSX

---

## Table of contents

1. Introduction
2. VDOM tree and nodes
3. Building the nodes
4. Building the tree
5. Diffing the tree
6. Patching the tree
7. What about hooks?
8. JSX

---

# Who am I?

## Guillaume St-Pierre

<div>
    <img 
        src="https://d1qb2nb5cznatu.cloudfront.net/startups/i/2945505-b32d393c3438940c1ed72d814542bd54-medium_jpg.jpg"
        alt="logo"
    />
    <img 
        src="https://www.manifold.co/static/images/team/gstpierre.jpg"
        alt="Me"
        style={{
            height: 200,
        }}
    />
</div>

* Software ~~Engineer~~ Developer at Manifold, a marketplace for cloud services
* Wannabe package author
* Also Carleton U student

---

# Why use a virtual DOM?

The virtual DOM allows us to represent the DOM tree using familiar JavaScript instead of the messy browser DOM API.

---

# Some history

The concept of the Virtual DOM was first developed in React.JS by Facebook. It changed the way we look at frontend development.

Many followed suit, including Vue.js, Hyperscript, Mithril...

<div>
    <img 
        src="https://cdn4.iconfinder.com/data/icons/logos-3/600/React.js_logo-512.png"
        alt="react"
        style={{
            height: 50,
        }}
    />
    <img 
        src="https://vuejs.org/images/logo.png"
        alt="vue"
        style={{
            height: 50,
        }}
    />
    <img 
        src="https://avatars2.githubusercontent.com/u/19475707?s=280&v=4"
        alt="mitrhil"
        style={{
            height: 50,
        }}
    />
    <img 
        src="https://user-images.githubusercontent.com/9027592/28045843-f4ddb724-65df-11e7-8f6e-4588fbd8417a.png"
        alt="snabdom"
        style={{
            height: 50,
        }}
    />
</div>

Even browsers went for similar concept with the Web Component standard.

---

# JSX

Facebook introduced JSX along with the virtual DOM, giving us the ability to add HTML inside JavaScript

<div style={{
    textAlign: 'left',
    display: 'flex',
    justifyContent: 'space-between',
}}>
    <SyntaxHighlighter language='javascript'>
        {`
const element = React.createElement(
    'h1',
    {className: 'greeting'},
    'Hello, world!'
);
        `}
    </SyntaxHighlighter>
    <SyntaxHighlighter language='jsx'> 
        {`
const element = (
    <h1 className="greeting">
        Hello, world!
    </h1>
);
        `}
    </SyntaxHighlighter>
</div>

---

# Some benchmarks

<img
    style={{
        height: '60vh',
    }}
    src="https://cdn-images-1.medium.com/max/2400/1*El9cBVFHxRG36XD8KNjA_g.png"
/>

Make your own at https://github.com/gothinkster/realworld

---

### Let's build one together.

---

# The virtual DOM tree and nodes

The first thing we will need for our virtual DOM implementation is a virtual DOM tree, a nested object structure representing our structure.

The tree is made of nodes which need to include their children, attributes and any data related to their types.

Let's look at the types of nodes we are likely to need

---

<CodeSurfer
    title="Base node constructor"
    code={require("!raw-loader!code/node_constructor.js").default}
    lang="javascript"
    showNumbers={false}
    theme={syntaxTheme}
    steps={[
        { notes: "Let's start with a constructor for our nodes" },
        { range: [1, 9], notes: 'The constructor loads the basic things we need' },
        { lines: [10], notes: 'A generic mount method' },
        { lines: [12], notes: 'A generic update method' },
        { lines: [14], notes: 'A generic remove method' },
        { lines: [16], notes: 'A generic clone method' },
    ]}
/>

export default Invert

---

# HTML nodes

An HTML node is able to manage the real DOM node associated to it.

In JSX, HTML nodes are nodes that are created with HTML tags, like `div` or `span`.

---

<CodeSurfer
    title="The HTML node constructor"
    code={require("!raw-loader!code/html_node_constructor.js").default}
    lang="javascript"
    showNumbers={false}
    theme={syntaxTheme}
    steps={[
        { notes: "That's big!" },
        { range: [1, 16], notes: 'We will need some dom information' },
        { range: [18, 22], notes: 'A mount method to add the DOM node' },
        { range: [23, 34], notes: 'Updating the node is a matter of changing its attributes and updating the DOM' },
        { range: [45, 82], notes: 'The update DOM method, meaty!' },
        { range: [47, 51], notes: 'Remove any event listeners' },
        { range: [54, 63], notes: 'Add the event listeners and attributes' },
        { range: [66, 81], notes: 'Setup the id and classes' },
        { range: [36, 43], notes: 'We also need to remove the event listeners when the DOM node is removed' },
    ]}
/>

export default Invert

---

Phew... Ready for the Text node?

---

# Text nodes

A Text node is like an HTML node, but only for pure text.

In the DOM, creating an HTML element and a text element use two different functions, so another node type is useful to us.

In JSX, text nodes are pure strings.

```jsx
<div>
    This will create a text node
    {'This will also create a text node'}
</div>
```

---

<CodeSurfer
    title="The Text node constructor"
    code={require("!raw-loader!code/text_node_constructor.js").default}
    lang="javascript"
    showNumbers={false}
    theme={syntaxTheme}
    steps={[
        { notes: "That's small!" },
        { range: [1, 4], notes: 'Much cleaner' },
        { range: [8, 10], notes: 'We only need the text' },
    ]}
/>

export default Invert

---

# Array nodes

An Array node is a node containing many nodes as its children. Also known as fragments in React.

This does not exists in the DOM, but it helps us with arrays in our virtual tree.

```jsx
<div>
    {['one', 'two', 'three'].map(obj => (
        <span key={obj}>{obj}</span>
    )}
</div>
```

---

<CodeSurfer
    title="The Array node constructor"
    code={require("!raw-loader!code/array_node_constructor.js").default}
    lang="javascript"
    showNumbers={false}
    theme={syntaxTheme}
    steps={[
        { notes: "I want more simple code like this" },
        { range: [1, 4], notes: 'We only get the children' },
        { range: [7, 10], notes: 'Update the children when needed' },
    ]}
/>

export default Invert

---

# Function nodes

A function node is a node that can rerender its children based on a function. More commonly know as function components.

This makes the virtual tree dynamic, but also adds the complexity of having to patch the DOM.

```jsx
const Component = ({ children }) => (
    <div>
        {children}
    </div>
);

<Component>
    I'm the child of a function node!
</Component>
```

---

<CodeSurfer
    title="The Function node constructor"
    code={require("!raw-loader!code/func_node_constructor.js").default}
    lang="javascript"
    showNumbers={false}
    theme={syntaxTheme}
    steps={[
        { notes: "Yes, it's that simple" },
        { lines: [1], notes: 'Get the render function' },
        { range: [2, 5], notes: 'Save everything' },
        { range: [9, 15], notes: 'Render the children. We should make sure children are always in an array' },
        { range: [17, 19], notes: 'Update the attributes for a future render' },
    ]}
/>

export default Invert

---

# Object nodes

An object node is a function node on steroids. They're objects (Or classes) with a render method, instance methods and potentially lifecycle methods.

In React, these are class components. In Mithril, they're object components.

For our framework, we will ignore these as functions and hooks are more than enough to get us started.

---

# Building Nodes

Nodes are created through the use of a node factory. In React, it's the `react.createElement` function.
                                                     
To make sure we are ready for JSX, let's follow the standard signature of `react.createElement` for our factory.

`function(tag, attributes, ...children)`

---

# Let's add some Hyperscript in there

React expects all tags to be only be HTML tags, but Hyperscript introduced the concept of having the DOM class and id directly in the tag.

In React:
```javascript
react.createElement('div', { id: 'test', className: 'foo bar' })
```

In Hyperscript: 
```javascript
h('div#test.foo.bar')
```

### Much nicer!

---

<CodeSurfer
    title="The node factory"
    code={require("!raw-loader!code/node_factory.js").default}
    lang="javascript"
    showNumbers={false}
    theme={syntaxTheme}
    steps={[
        { range: [1, 14], notes: 'The internal factory that creates all the nodes' },
        { range: [16, 21], notes: 'Utility function for cases like the pure text node' },
        { range: [17, 19], notes: 'Vdonizing our nodes makes sure that everything in our tree is a valid node' },
        { range: [23, 35], notes: 'Our exported factory' },
        { lines: [2], notes: 'We create a unique id to keep track of our nodes' },
        { range: [3, 5], notes: 'If we are given a function, it is a function node' },
        { range: [6, 8], notes: 'If we are given an array, it is an array node' },
        { range: [9, 11], notes: 'If we had to vondize this node, probably a text node' },
        { lines: [12, 13], notes: 'The selector extractor adds the Hyperscript functionality for HTML nodes' },
    ]}
/>

export default Invert

---

# Why `vnodize`?

Whether using the Hyperscript notation or JSX, both support having pure string as children

<div style={{
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'space-around',
}}>
    <SyntaxHighlighter>
        {`h('div', {}, 'test')`}
    </SyntaxHighlighter>
    Or
    <SyntaxHighlighter>
        {`<div>test</div>`}
    </SyntaxHighlighter>
</div>

"Vnodizing" the children makes sure that even this translates to a node.

---

# Building the tree

Building the virtual tree is usually a two step process.

<ol>
    <Appear>
        <li>Walk the tree structure, rendering any function or classes along the way.</li>
        <li>Walk the tree again, mounting any HTML and text node to a DOM node.</li>
    </Appear>
</ol>

---

### These two steps are not universal

Some frameworks do both at the same time.

Some frameworks do not mount the tree and instead use their diffing algorithm.

---

<CodeSurfer
    title="Building the tree"
    code={require("!raw-loader!code/tree_build.js").default}
    lang="javascript"
    showNumbers={false}
    theme={syntaxTheme}
    steps={[
        { notes: "One recursive function" },
        { range: [2, 4], notes: 'Render function nodes' },
        { lines: [6], notes: 'Run recursively' },
    ]}
/>

export default Invert

---

<CodeSurfer
    title="Mounting the tree"
    code={require("!raw-loader!code/tree_mount.js").default}
    lang="javascript"
    showNumbers={false}
    theme={syntaxTheme}
    steps={[
        { notes: "Another recursive function" },
        { range: [4, 8], notes: 'Create the two types of elements' },
        { range: [10, 15], notes: `Also patch the DOM while we're at it` },
        { lines: [18], notes: 'Run recursively' },
    ]}
/>

export default Invert

---

<CodeSurfer
    title="Let's try it out"
    code={require("!raw-loader!code/demo1.js").default}
    lang="javascript"
    showNumbers={false}
    theme={syntaxTheme}
    steps={[
        { notes: "utils.mount is a utility function to build and mount our tree, l is our node factory" },
    ]}
/>

export default Invert

---

<RunCode code={element => {
   utils.mount(element, l('div#test.test', {
       style: 'color: red;',
   }, 'Hello World'));
}}/>

---

# Updating the tree

Building the tree is great, but what if we want to update it based on some event or data change?

This is done using a diffing algorithm.

---

# 50 shades of diffing

Through my research, I have seen countless diffing algorithms.

I was able to sort most of them into three diffing methods, let's look at them.

---

# The "virtual diff" method

This algorithm keeps a copy of the virtual DOM tree in memory at all times. When an update is requested, a new tree is built.

Both trees are compared and any differences creates a patch, a small object containing what to do for that node.

React uses this method for its own diffing algorithm, it has the advantage of being "DOM-less"

We will be using this method

---

# "virtual diff" patching

When we have all the patches ready, they can be applied on the DOM and the in-memory tree.

Using this patch system allows us to patch anything using the saved information, not only the DOM or our tree.

---

# The "DOM diff" method

This algorithm works very similarly to the virtual compare method, but compares against the real DOM tree instead of an in-memory tree.

Patches are still created from the diff, but we only need to patch the actual DOM tree.

Diffing DOM nodes is supposedly very fast.

---

# "DOM diff" patching

The patches from the DOM compare method only need to be applied to the DOM itself.

While we aren't locked into using these patches only in a browser, we need the browser to generate them.

---

# The "inline" method

Building and diffing trees is costly, so why not apply updates immediately to the DOM?

Rather than request an update to the tree, all changes are made manually or automatically on the DOM nodes.

This can be hard to reason with, to the point where languages were created to abstract that away. See Imba.

---

# How to diff

Diffing a tree is a matter of diffing its nodes. We walk the new tree and the compared tree at the same time.

---

<CodeSurfer
    title="First, we need to make our build function able to build multiple trees"
    code={require("!raw-loader!code/tree_build_modified.js").default}
    lang="javascript"
    showNumbers={false}
    theme={syntaxTheme}
    steps={[
        { notes: "We now add the ability to keep nodes in memory" },
        { lines: [1], notes: 'First, we need a dictionary of nodes' },
        { lines: [5], notes: 'When building a node, check if we know of it already' },
        { range: [8, 11], notes: `If not or if they're different, we update our known node` },
        { range: [14, 16], notes: 'Clone that node to prevent mutations' },
        { range: [23, 33], notes: 'If we knew the node, make sure we keep the same ids' },
        { range: [33, 35], notes: 'Otherwise, do like we did before' },
    ]}
/>

export default Invert

---

<CodeSurfer
    title="Now, let's implement our diffing algorithm"
    code={require("!raw-loader!code/tree_diff.js").default}
    lang="javascript"
    showNumbers={false}
    theme={syntaxTheme}
    steps={[
        { notes: "Implemented code" },
        { range: [1, 5], notes: 'Remember our patch types?' },
        { range: [9, 12], notes: 'Insert if the old node is missing' },
        { range: [14, 17], notes: 'Remove if the new node is missing' },
        { range: [19, 31], notes: 'Little modification here to also update if there are event listeners' },
        { range: [34, 48], notes: 'Patch if different, but of the same type' },
        { range: [48, 52], notes: 'Replace if different type' },
    ]}
/>

export default Invert

---

# But what is patching?

When two trees are diffed, we generate patches for each node.

We save those patches in a registry for later use.

While each framework has their own set of patch types, I have identified a few that will be the most useful to us.

---

## The five patch types

<ul style={{ textAlign: 'left' }}>
    <li>The text patch to update the text of a text node.</li>
    <li>The node patch to update everything in a node.</li>
    <li>The insert patch to insert a new child in a parent at a specific index.</li>
    <li>The replace patch to replace a child from a parent with another child.</li>
    <li>The remove patch to remove a child in a parent at a specific index.</li>
</ul>

---

# How to patch

There are two way I've found to patch a virtual or DOM tree, both have values and drawbacks

1. Walk the tree and look for patches in the registry on each node.
2. Loop over the patches and walk the tree to find the patched node.

---

<CodeSurfer
    title={`We'll use the "walk the tree method"`}
    code={require("!raw-loader!code/tree_patch.js").default}
    lang="javascript"
    showNumbers={false}
    theme={syntaxTheme}
    steps={[
        { notes: "Implemented code" },
        { lines: [1], notes: "The patch operations array" },
        { range: [4, 7], notes: 'Loop on all operations for that node' },
        { range: [8, 24], notes: 'Handle each patch with its own function' },
        { range: [35, 44], notes: 'Continue through the tree recursively' },
        { range: [47, 57], notes: 'Patch text' },
        { range: [59, 61], notes: 'Patch node' },
        { range: [63, 78], notes: 'Patch insert' },
        { range: [80, 96], notes: 'Patch remove' },
        { range: [98, 111], notes: 'Patch replace' },
    ]}
/>

export default Invert

---

<CodeSurfer
    title="Let's try it out"
    code={require("!raw-loader!code/demo2.js").default}
    lang="javascript"
    showNumbers={false}
    theme={syntaxTheme}
    steps={[
        { notes: "Now we have a function with state" },
    ]}
/>

export default Invert

---

<RunCode code={element => {
   let count = 0;
   
   function counter() {
       count += 1;
       utils.update();
   }
   
   utils.mount(element, l(() => l('div#test.test', {
       style: 'color: red;',
   }, l('button', {
      click: counter,
   }, `${count} click`))));
}}/>

---

# Maybe something a bit more meaty?

---

<CodeSurfer
    title="Now with array nodes"
    code={require("!raw-loader!code/demo3.js").default}
    lang="javascript"
    showNumbers={false}
    theme={syntaxTheme}
    steps={[
        { notes: "We create a new child for each click" },
    ]}
/>

export default Invert

---

<RunCode code={element => {
   let count = 0;
                   
   function counter() {
       count += 1;
       utils.update();
   }
   
   utils.mount(element, l(() => {
       const childrenMap = [];
       for (let i = 0; i < count; i++) {
           childrenMap.push(`child ${i}`);
       }
   
       return l('div#test.test', {
           style: 'color: red;',
       }, [
           l('button', {
               click: counter,
           }, `${count} click`),
           count % 2 === 0 ? l('span.even', {}, 'Even') : l('span.odd', {}, 'Odd'),
           l('div.test3', {}, childrenMap),
       ]);
   }));
}}/>

---

# What about hooks?

Hooks are the newest feature from React that allows us to add state to function components as if they were a class component, but how do they work exactly?

---

# State, before hooks

In React, if you wanted to have state with your component, we used to have to implement a class component.

```jsx
class Component extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            open: false
        };
    }
    
    setOpen = () => { this.setState({ open: true }) }

    render() { 
        const { open } = this.state;
        ...
    }
}
```

---

# State, after hooks

With hooks, state is now available to function components! React keeps tracks of the function's instance for providing the state.

```jsx
const Component = () => {
    const [open, setOpen] = useState(false);
    
    ...
};
```

---

## Behind the scenes, hooks are very simple and work in a three step process.

1. Set the current function node instance of the hooks manager
2. Run the function node render method
3. Set the current node instance back to what it was before

**React adds a lot to this with reducers and keeping track of state changes, but hooks boil down to those three steps.**

---

<CodeSurfer
    title="We need to update the render code of our function node"
    code={require("!raw-loader!code/func_node_hooks.js").default}
    lang="javascript"
    showNumbers={false}
    theme={syntaxTheme}
    steps={[
        { notes: "Implemented code" },
        { range: [12, 23], notes: 'The new render method' },
        { range: [13, 14], notes: 'Save the old current element and set the node' },
        { range: [16, 19], notes: 'Render' },
        { lines: [21], notes: 'Reset the current element to the previous one' },
    ]}
/>

export default Invert

---

<CodeSurfer
    title="The hooks manager itself"
    code={require("!raw-loader!code/hooks_store.js").default}
    lang="javascript"
    showNumbers={false}
    theme={syntaxTheme}
    steps={[
        { notes: "That's pretty simple" },
        { lines: [2], notes: 'The current element' },
        { lines: [4], notes: 'A map of elements and their states' },
        { range: [6, 18], notes: 'The useState function, named hookState here' },
        { lines: [7], notes: 'Get the id from the current element' },
        { range: [8, 12], notes: 'Check if the map has that element, if not, set to the initial state' },
        { range: [14, 17], notes: 'Return the state value and the state setter' },
        { lines: [21], notes: 'Export a function to use that hook' },
    ]}
/>

export default Invert

---

<CodeSurfer
    title="Rewrite our counter example with hooks"
    code={require("!raw-loader!code/demo4.js").default}
    lang="javascript"
    showNumbers={false}
    theme={syntaxTheme}
    steps={[
        { notes: "It looks much better now" },
    ]}
/>

export default Invert

---

<RunCode code={element => {
   utils.mount(element, l(() => {
       const [count, setCount] = hookState(0);
   
       const setState = () => {
           setCount(count + 1);
           utils.update();
       };
   
       const childrenMap = [];
       for (let i = 0; i < count; i++) {
           childrenMap.push(`child ${i}`);
       }
   
       return l('div#test.test', {
           style: 'color: red;',
       }, [
           l('button', {
               click: setState,
           }, `${count} click`),
           count % 2 === 0 ? l('span.even', {}, 'Even') : l('span.odd', {}, 'Odd'),
           l('div.test3', {}, childrenMap),
       ]);
   }));
}}/>

---

# What about JSX?

We've been working without JSX up until this point, but can we add JSX to our library?

---

### Yes!

Facebook wrote an amazing Babel plugin called `@babel/plugin-transform-react-jsx`, all we have to do is configure it.

```json
{
  ...,
  "plugins": [
    [
      "@babel/plugin-transform-react-jsx",
      {
        "pragma": "l"
      }
    ]
  ],
  ...
}
```

---

<CodeSurfer
    title="Our counter example with JSX"
    code={require("!raw-loader!code/demo5.js").default}
    lang="jsx"
    showNumbers={false}
    theme={syntaxTheme}
    steps={[
        { notes: "Fancy!" },
    ]}
/>

export default Invert

---

# What did we just create?

We created, within the scope of this 40 minutes talk, a "feature complete" front-end framework for creating dynamic UIs with some of the latest trends baked in.

---

Do you want to play with our creation? Fork it and create your own?

The entire code + other experiments/failures are available on GitHub!

https://github.com/Minivera/lander

---

<CodeSurfer
    title="Here is how I managed to have the demos work in mdx-deck"
    code={require("!raw-loader!RunCode.js").default}
    lang="jsx"
    showNumbers={false}
    theme={syntaxTheme}
    steps={[
        { notes: "Ref magic" },
    ]}
/>

export default Invert
